{"version":3,"sources":["webpack://@jsii/runtime/./bin/jsii-runtime.ts","webpack://@jsii/runtime/external \"child_process\"","webpack://@jsii/runtime/external \"console\"","webpack://@jsii/runtime/external \"os\"","webpack://@jsii/runtime/external \"path\"","webpack://@jsii/runtime/external \"process\"","webpack://@jsii/runtime/webpack/bootstrap","webpack://@jsii/runtime/webpack/startup"],"names":["child","spawn","execPath","execArgv","resolve","__dirname","stdio","once","code","signal","exit","signals","err","console","error","stack","Object","keys","on","sig","kill","makeHandler","tag","chunk","buffer","Buffer","from","JSON","stringify","toString","stdout","stderr","commands","stdin","pipe","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":";;;;;;;;QAAA;QACA;QACA;QACA;QACA;QAQA,MAAMA,QAAQ,gBAAAC,MACZ,UAAAC,UACA,KAAI,UAAAC,UAAU,OAAAC,QAAQC,WAAW,MAAM,OAAO,iBAC9C;YAAEC,OAAO,EAAC,UAAU,QAAQ,QAAQ;;QAKtCN,MAAMO,KAAK,QAAO,CAACC,MAAMC;;YACvB,IAAIA,UAAU,MAAM;gBAGlB,UAAAC,KAAK,QAAM,KAAC,eAAGC,QAAQF,aAAkC,6BAAI;;YAG/D,UAAAC,KAAKF;;QAGPR,MAAMO,KAAK,UAAUK;YACnBC,QAAQC,MAAM,kCAAkCF,IAAIG;YACpD,UAAAL,MAAM;;QAGR,KAAK,MAAMD,UAAUO,OAAOC,KAAK,eAAGN,UAAU;YAE5C,IAAIF,WAAW,aAAaA,WAAW,WAAW;gBAChD;;YAIF,UAAAS,GAAGT,SAASU,OAAQnB,MAAMoB,KAAKD;;QAiBjC,SAASE,YACPC;YAEA,OAAQC;gBACN,MAAMC,SAASC,OAAOC,KAAKH;gBAC3B,UAAAT,MAAMa,KAAKC,UAAU;oBAAE,CAACN,MAAME,OAAOK,SAAS;;;;QAIlD7B,MAAM8B,OAAOZ,GAAG,QAAQG,YAAY;QACpCrB,MAAM+B,OAAOb,GAAG,QAAQG,YAAY;QAMpC,MAAMW,WAAoBhC,MAAMM,MAAc;QAE9C,UAAA2B,MAAMC,KAAKF;QAEXA,SAASE,KAAK,UAAAJ;;;QC/EdK,OAAOC,UAAUC,QAAQ;;;QCAzBF,OAAOC,UAAUC,QAAQ;;;QCAzBF,OAAOC,UAAUC,QAAQ;;;QCAzBF,OAAOC,UAAUC,QAAQ;;;QCAzBF,OAAOC,UAAUC,QAAQ;;;;ACCzB,IAAIC,2BAA2B;;AAG/B,SAASC,oBAAoBC;IAE5B,IAAGF,yBAAyBE,WAAW;QACtC,OAAOF,yBAAyBE,UAAUJ;;IAG3C,IAAID,SAASG,yBAAyBE,YAAY;QAGjDJ,SAAS;;IAIVK,oBAAoBD,UAAUL,QAAQA,OAAOC,SAASG;IAGtD,OAAOJ,OAAOC;;;AClBfG,oBAAoB","file":"bin/jsii-runtime.js","sourcesContent":["import { spawn } from 'child_process';\nimport { error } from 'console';\nimport { constants as os } from 'os';\nimport { resolve } from 'path';\nimport { execArgv, execPath, exit, on, stdin, stdout } from 'process';\nimport { Duplex } from 'stream';\n\n// Spawn another node process, with the following file descriptor setup:\n// - No STDIN will be provided\n// - STDOUT and STDERR will be intercepted, contents wrapped & forward to STDERR\n// - FD#3 is the communication pipe to read jsii API messages\n// - FD#4 is the communication pipe to write jsii API responses\nconst child = spawn(\n  execPath,\n  [...execArgv, resolve(__dirname, '..', 'lib', 'program.js')],\n  { stdio: ['ignore', 'pipe', 'pipe', 'pipe'] },\n);\n\n//#region Exit, error and signal forwarders\n\nchild.once('end', (code, signal) => {\n  if (signal != null) {\n    // Child was killed by signal, this is usually reflected by exiting with\n    // 128 + <signal code>\n    exit(128 + (os.signals[signal as keyof typeof os.signals] ?? 0));\n  }\n  // Child exited, so we reflect it's exit code to our creator\n  exit(code);\n});\n\nchild.once('error', (err) => {\n  console.error('Failed to spawn child process:', err.stack);\n  exit(-1);\n});\n\nfor (const signal of Object.keys(os.signals)) {\n  // Those signals cannot be trapped (libuv would throw EINVAL).\n  if (signal === 'SIGKILL' || signal === 'SIGSTOP') {\n    continue;\n  }\n\n  // Forward all signals to the child\n  on(signal, (sig) => child.kill(sig));\n}\n\n//#endregion\n\n//#region STDOUT and STDERR handlers\n\n/**\n * Creates chunk handlers for the child process' STDOUT and STDERR, which will\n * forward any data received through to this process' STDERR after having base64\n * encoded the data and wrapped it in a simple JSON blob denoting which stream\n * the data is for.\n *\n * @param tag the name of the stream (stdout or stderr) that received the data\n *\n * @returns a new handler for the `Readable.on('data', handler)` event.\n */\nfunction makeHandler(\n  tag: 'stdout' | 'stderr',\n): (chunk: string | Buffer) => void {\n  return (chunk) => {\n    const buffer = Buffer.from(chunk);\n    error(JSON.stringify({ [tag]: buffer.toString('base64') }));\n  };\n}\n\nchild.stdout.on('data', makeHandler('stdout'));\nchild.stderr.on('data', makeHandler('stderr'));\n\n//#endregion\n\n//#region Piping jsii API requests & responses\n\nconst commands: Duplex = (child.stdio as any)[3];\n// Forwarding requests from this process' STDIN to the child's FD#3\nstdin.pipe(commands);\n// Forwarding responses from the child's FD#3 to this process' STDOUT\ncommands.pipe(stdout);\n\n//#endregion\n","module.exports = require(\"child_process\");;","module.exports = require(\"console\");;","module.exports = require(\"os\");;","module.exports = require(\"path\");;","module.exports = require(\"process\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n__webpack_require__(3143);\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}